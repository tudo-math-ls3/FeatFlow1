/****************************************************************************
                  INTERNATIONAL AVS CENTER
	(This disclaimer must remain at the top of all files)

WARRANTY DISCLAIMER

This module and the files associated with it are distributed free of charge.
It is placed in the public domain and permission is granted for anyone to use,
duplicate, modify, and redistribute it unless otherwise noted.  Some modules
may be copyrighted.  You agree to abide by the conditions also included in
the AVS Licensing Agreement, version 1.0, located in the main module
directory located at the International AVS Center ftp site and to include
the AVS Licensing Agreement when you distribute any files downloaded from 
that site.

The International AVS Center, MCNC, the AVS Consortium and the individual
submitting the module and files associated with said module provide absolutely
NO WARRANTY OF ANY KIND with respect to this software.  The entire risk as to
the quality and performance of this software is with the user.  IN NO EVENT
WILL The International AVS Center, MCNC, the AVS Consortium and the individual
submitting the module and files associated with said module BE LIABLE TO
ANYONE FOR ANY DAMAGES ARISING FROM THE USE OF THIS SOFTWARE, INCLUDING,
WITHOUT LIMITATION, DAMAGES RESULTING FROM LOST DATA OR LOST PROFITS, OR ANY
SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES.

This AVS module and associated files are public domain software unless
otherwise noted.  Permission is hereby granted to do whatever you like with
it, subject to the conditions that may exist in copyrighted materials. Should
you wish to make a contribution toward the improvement, modification, or
general performance of this module, please send us your comments:  why you
liked or disliked it, how you use it, and most important, how it helps your
work. We will receive your comments at avs@ncsc.org.

Please send AVS module bug reports to avs@ncsc.org.

******************************************************************************/


/*

 AUTHOR: Alex Knowles

 For further information please contact:

  The Computer Graphics Unit
  Manchester Computing Centre
  The University of Manchester
  Manchester M13 9PL
  United Kingdom

  tel: +44 61 275 6095
  fax: +44 61 275 6040

  email: cgu-info@mcc.ac.uk
*/

/*__________________________________________________________________________
Alex Knowles
Manchester Computing Centre, Computer Graphics Unit	   Tel. 061 275 6095
E-Mail	ark@hpa.cgu.mcc.ac.uk
        alex@ed.ac.uk
--------------------------------------------------------------------------*/

/* a module to create mpeg movies of images passed to it. They must be
   of consistant size. Small images look good. Large Images are slow and
   jerky on replay.
*/

#include <stdio.h>
#include <avs/avs.h>
#include <avs/port.h>
#include <avs/field.h>

#include <string.h>
 
/* IAC CODE CHANGE
#ifdef  _INCLUDE_POSIX_SOURCE
#include <unistd.h>
#include <symlink.h>
#else
#define  _INCLUDE_POSIX_SOURCE
#include <unistd.h>
#include <symlink.h>
#undef _INCLUDE_POSIX_SOURCE
#endif
   IAC CODE CHANGE */

#define TRUE 1
#define FALSE 0
#define MIN(a,b)	((a)>(b) ? (b) : (a))	/* minimum of a and b        */
#define MAX(a,b)	((a)>(b) ? (a) : (b))	/* maximum of a and b        */
#define CORRECT(x)	MIN( MAX((x),0), 255)	/* limits x to range 0->255  */
#define MATCH(a,b)	( strcmp(a,b)==0 )	/* true if strings are same  */
#define PIXELS(x)	(width*height)		/* num of pixels in an image */
#define BYTES(x)	(PIXELS(x)*4)		/* num of bytes in an image  */
#define EVEN(x)		(( (x)%2==1 ) ? (x)-1 : (x) ) /* round down to an even num */

typedef unsigned char byte;

char	mpegfile[512];
int	mpegcount=0;
int	width, height;

/* function prototypes */
void make_mpeg();
void do_mpeg();
void clear_mpegtemp();
void repeat_mpeg();

/* *****************************************/
/*  Module Description                     */
/* *****************************************/
int Create_MPEG_desc()
{
  int in_port, out_port, param, iresult;
  extern int Create_MPEG_compute();
  
  AVSset_module_name("Create MPEG", MODULE_RENDER);
  
  /* Input Port Specifications               */
  in_port = AVScreate_input_port("input", 
				 "field 2D 4-vector uniform byte", REQUIRED);
  
  /* Parameter Specifications                */
  param = AVSadd_parameter("filename", "string", "", "", "*");
  AVSconnect_widget(param, "browser");
  AVSadd_parameter_prop(param,"height","integer",10);

  param = AVSadd_parameter("Pause", "boolean", 1, 0, 1);
  AVSconnect_widget(param, "toggle");

  param = AVSadd_parameter("Forget it", "oneshot", 0, 0, 1);
  AVSconnect_widget(param, "oneshot");

  param = AVSadd_parameter("Make it", "oneshot", 0, 0, 1);
  AVSconnect_widget(param, "oneshot");

  param = AVSadd_parameter("Repeat", "oneshot", 0, 0, 1);
  AVSconnect_widget(param, "oneshot");

  param = AVSadd_parameter("size","string","Width : 000 Height : 000", "", "");
  AVSconnect_widget(param, "text");
  AVSadd_parameter_prop(param,"width","integer",4);

  param = AVSadd_parameter("Frame", "string", "Frame : 000", "", "");
  AVSconnect_widget(param, "text");
  AVSadd_parameter_prop(param,"width","integer",4);
  
  AVSset_compute_proc(Create_MPEG_compute);
  
  return(1);
}
 
/* *****************************************/
/* Module Compute Routine                  */
/* *****************************************/
int Create_MPEG_compute( input, filename, pause, forget, make, repeat )
     AVSfield_char *input;	/* the input image to be added to the movie */
     char *filename;		/* filename of mpeg movie.. with directory  */
     int pause;			/* pausing means add no more images	    */
     int forget;		/* cancel this movie and erase temp files   */
     int make;			/* shall i make it   and erase temp files   */
     int repeat;		/* repeat the last frame ???		    */
{
  char line[20]; 		/* the frame count is built up in this	    */

  if( input ){			/* update the size of the input image	    */
    sprintf(line, "Width : %03d Height : %03d",
	    EVEN( MAXX( input ) ),  EVEN( MAXY( input ) ) );
    AVSmodify_parameter("size",AVS_VALUE,line,"","");
  }

	/* make it so that you can't turn off pause unless a file is chosen */
  if( AVSparameter_changed("Pause") && (MATCH(filename,"")||filename==NULL) ) {
    AVSwarning("You can't start a movie without specifying a file.\n");
    AVSmodify_parameter("Pause",AVS_VALUE,1,0,1);
    return(1);
  }
  
  if( AVSparameter_changed("filename") ){
    if( mpegcount==0 ){
      strcpy(mpegfile,filename);/* copy over the file name in to mpegfile   */
    } else {
      AVSwarning("You can't change the filename while\nyou're making a movie!!!\nEither finish this one or start a new one\n");
      				/* now make filename what it should be      */
      AVSmodify_parameter("frame",AVS_VALUE,mpegfile,"","");
    }
  }

  if( AVSinput_changed("input",0) && !pause && !MATCH(filename,"") )
    do_mpeg(input);			/* add this frame to the sequence   */
  else
    if(mpegcount>0)
      if( repeat && !pause )
	repeat_mpeg();			/* make links to the last frame     */
      else{
	AVSmodify_parameter("Pause",AVS_VALUE,1,0,1);	/* turn pause on    */
	if( make ){
	  make_mpeg();				/* make the mpeg movie	    */
	  clear_mpegtemp();			/* erase all the temp files */
	} else
	  if( forget ){
	    clear_mpegtemp();	/* erase all the temp files */
	    putchar('\n');
	  }
      }

  sprintf( line, "Frame : %03d",mpegcount);
  AVSmodify_parameter("Frame",AVS_VALUE,line,"","");

  return(1);
}

/* ***********************************************************************/
/* Initialization for modules contained in this file.                    */
/* ***********************************************************************/
static int ((*mod_list[])()) = {  Create_MPEG_desc  };
#define NMODS (sizeof(mod_list) / sizeof(char *))
     
AVSinit_modules()
{
  AVSinit_from_module_list(mod_list, NMODS);
}
 
/* ***********************************************************************/
/* subroutines by ARK... subroutines 'r' us!!! 				 */
/* ***********************************************************************/
  
/* gives Y luminance value in range 0->255	*/
#define Yval(ptr)	(0.2989*((float)*(ptr+1))+	/* red   */	\
			 0.5866*((float)*(ptr+2))+	/* green */	\
			 0.1144*((float)*(ptr+3)) )	/* blue  */

/* gives U -- blue chroma value in rangle -127->128	*/
#define Uval(ptr)       (0.493*(0.8856*((float)*(ptr+3))-   /* blue  */	\
				0.5866*((float)*(ptr+2))-   /* green */	\
				0.2989*((float)*(ptr+1)) ) )/* red   */

/* gives V -- red chroma value in rangle -127->128	*/
#define Vval(ptr)	(0.877*(0.7011*((float)*(ptr+1))-   /* red   */	\
				0.5866*((float)*(ptr+2))-   /* green */	\
				0.1144*((float)*(ptr+3)) ) )/* blue  */

void do_mpeg( image )
     AVSfield_char* image;			/* the image to encode	    */
{
  FILE	*out;		/* the file to write. only 1 file open at any time  */
  int	x,y,
	err,			/* error value returned by file functions   */
	bufptr;				/* index into the buffer array	    */
  byte	*buffer,		/* array to store different images in	    */
	*ptr=NULL;				/* pointer into an image    */
  float	Y,U,V;						/* YUV values	    */
  char 	fname[255];		/* array to build up temp filename in	    */
  byte	ERROR=FALSE;

  AVSmodule_status("Adding Frame",0);

  if( mpegcount==0 ){
    /* This is the first image */
    width =EVEN( MAXX(image) );
    height=EVEN( MAXY(image) );
    printf("First Image recieved by Create MPEG dimensions %d %d\n",
	   width, height );
  } else {
    /* check that the image is the right size */
    if( width!=EVEN(MAXX(image)) || height!=EVEN(MAXY(image)) ){
      /* the size of the input has changed */
      AVSwarning("The size of the input image has been changed.\nThis image has been ignored.\nEither return size of input image to %03d %03d,\nor forget this movie and start a new one\n",width,height);
      return;
    }
  }

  buffer=calloc( PIXELS(image), sizeof( byte ) );

  if( !buffer ){
    AVSerror("Failed to allocate memory for YUV buffer\n");
    return;
  }
      
  printf("Doing MPEG..for frame %d", mpegcount );

/* Y luminescence stored as one byte per pixel */
  /* make ptr point to alpha at top of image nad fill up buffer */
  ptr=I2DV(image,0,0);
  for( y=0 ; y < height ; y++ ){
    ptr=I2DV(image,0,y);
    for( x=0 ; x < width ; x++ ){
      buffer[x+y*width]=(byte) CORRECT(Yval(ptr));
      ptr+=4;
    }
  }
  /* WRITE the Y file */
  sprintf(fname,"%s_temp%d.Y",mpegfile,mpegcount);
  out=fopen(fname,"w");
  if( !out ){
    AVSerror("Could not open temporary MPEG file %s",fname);
    ERROR=TRUE;
  } else {
    err=fwrite(buffer , sizeof(byte) , PIXELS(image) , out);
    if( err != PIXELS(image) ){
      AVSerror("Failed to write whole Y file %s\nOnly wrote %d bytes",
	       fname,err);
      ERROR=TRUE;
    }
    fclose(out);
  }

  /* free the memory used by buffer that is no longer needed */
  realloc( buffer, PIXELS(image)/4 );

  AVSmodule_status("Adding Frame",33);
/* U blue chroma stored as one byte per 4 pixels */
  /* fill up buffer with U */
  bufptr=0;
  for( y=0 ; y < height ; y+=2 )
    for( x=0 ; x < width ; x+=2 ){
      ptr=I2DV( image, x  , y  );	U =Uval(ptr);	/* top left	*/
      ptr+=4;				U+=Uval(ptr);	/* top right	*/
      ptr=I2DV( image, x  , y+1  );	U+=Uval(ptr);	/* bottom left  */
      ptr+=4;				U+=Uval(ptr);	/* bottom right */
      buffer[bufptr++]=(byte) CORRECT(U/4.0+128.0);
    }

  /* save the U file */
  sprintf(fname,"%s_temp%d.U",mpegfile,mpegcount);
  out=fopen(fname,"w");
  if( !out ){
    AVSerror("Could not open temporary MPEG file %s",fname);
    ERROR=TRUE;
  } else {
    err=fwrite( buffer , sizeof(byte) , PIXELS(image)/4 , out);
    if( err != PIXELS(image)/4 ){
      AVSerror("Failed to write whole U file %s\nOnly wrote %d bytes",
	       fname,err);
      ERROR=TRUE;
    }
    fclose(out);
  }

  AVSmodule_status("Adding Frame",66);
/* V red chroma stored as one byte per 4 pixels */
  /* fill up buffer with V */
  bufptr=0;
  for( y=0 ; y < height ; y+=2 )
    for( x=0 ; x < width ; x+=2 ){
      ptr=I2DV( image, x  , y  );	V =Vval(ptr);	/* top left	*/
      ptr+=4;				V+=Vval(ptr);	/* top right	*/
      ptr=I2DV( image, x  , y+1  );	V+=Vval(ptr);	/* bottom left  */
      ptr+=4;				V+=Vval(ptr);	/* bottom right */
      buffer[bufptr++]=(byte) CORRECT(V/4.0+128.0);
    }

  /* save the V file */
  sprintf(fname,"%s_temp%d.V",mpegfile,mpegcount);
  out=fopen(fname,"w");
  if( !out ){
    AVSerror("Could not open temporary MPEG file %s",fname);
    ERROR=TRUE;
  } else {
    err=fwrite( buffer , sizeof(byte) , PIXELS(image)/4 , out );
    if( err != PIXELS(image)/4 ){
      AVSerror("Failed to write whole V file %s\nOnly wrote %d bytes",
	       fname,err);
      ERROR=TRUE;
    }
    fclose(out);
  }

  if( !ERROR )  mpegcount++;	/* only increse frame count is no errors    */

/* IAC CODE CHANGE :   free( buffer ); */
   free(buffer );
  printf("...Done   \r"); fflush(stdout);
}

/* repeat_mpeg makes a symbolic link to the last frame written and
 * increments mpegcount.
 */
void repeat_mpeg()
{
  char 	fname[512],
       	oldfname[512];
  int 	err=0;

  printf("Repeating MPEG..for frame %d", mpegcount );

  if( mpegcount==0 ){
    AVSwarning("Whoops. This is the first image in the sequence\n");
  } else {
    AVSmodule_status("Repeating Frame",0);
    sprintf(oldfname,"%s_temp%d.Y",mpegfile,mpegcount-1);
    sprintf(fname,   "%s_temp%d.Y",mpegfile,mpegcount);
    err+=symlink( oldfname, fname );

    AVSmodule_status("Repeating Frame",33);
    sprintf(oldfname,"%s_temp%d.U",mpegfile,mpegcount-1);
    sprintf(fname,   "%s_temp%d.U",mpegfile,mpegcount);
    err+=symlink( oldfname, fname );

    AVSmodule_status("Repeating Frame",66);
    sprintf(oldfname,"%s_temp%d.V",mpegfile,mpegcount-1);
    sprintf(fname,   "%s_temp%d.V",mpegfile,mpegcount);
    err+=symlink( oldfname, fname );

    if( err ){
      AVSerror("Failed when symlink-ing duplicate frame files in repeat_mpeg\nThis frame has been ignored\n");
      return;
    } else 
      mpegcount++;
  }
  printf("...Done   \r");	fflush(stdout);
}

/* takes all the mpeg temp files and makes a movie and then removes
   all the temp files
*/
void make_mpeg()
{
  char  lineout[1024];
  
  AVSmodule_status("Creating MPEG",50);
  sprintf(lineout,"mpeg %s -a 0 -b %d -h %d -v %d -s %s %s_temp >%s_message",
	  ( width%16==0 && height%16==0 ) ? "" : "-PF",
	  mpegcount-1, width, height, mpegfile, mpegfile, mpegfile );
  printf("\nEXECUTING : %s\n",lineout);
  system( lineout );
}

/* clear_mpegtemp -- removes all the temp files */
void clear_mpegtemp()
{
  int x,err;
  char fname[256];

  for( x=mpegcount-1 ; x>=0 ; x-- ){
    AVSmodule_status("Erasing Temp files",
		     (int) ((1.0-(float)((float)x/(float)mpegcount))*100.0));
    sprintf(fname,"%s_temp%d.Y",mpegfile,x); err =remove(fname);
    sprintf(fname,"%s_temp%d.U",mpegfile,x); err+=remove(fname);
    sprintf(fname,"%s_temp%d.V",mpegfile,x); err+=remove(fname);
    if( err!=0 )
      AVSerror( "Failed when remove temporary files near\n%s\n",fname );
  }
  mpegcount=0;
  putchar(10);
}









